%% Inviscid wall-bounded flow Manufactured Solution
% see Navah & Nadarajah, 2020: On the verification of CFD solvers of all orders
% of accuracy on curved wall-bounded domains and for realistic RANS flows
clc; clear; close all;

%% Inviscid flows on curved wall-bounded domain: MS-1
% A grid set is generated by sequentially removing every other grid line from 
% the finest grid of 1024 Ã— 256 quadrangular elements for which the element 
% sizes are distributed following a geometric series with fixed expansion ratios
% of rX = 0.993 and rY = 1.0 in the corresponding undeformed coordinates 
% directions. The transformation is then applied to resulting grid and solution 
% node coordinates to retrieve the tessellation of the deformed domain.

% fine grid
Nfine = [1024,256] + 1;

GRID = ms1_grid(16,Nfine);
prim = prim_vars(GRID.x,GRID.y);

GRID2 = cartesian_grid_gen(100,100,1);
GRID2.x = 1.1*GRID2.x/100 + 0.9;
GRID2.y = 0.6*GRID2.y/100 + 0.0;

figure(1);
contourf(GRID.x,GRID.y,prim(:,:,4),10)
colorbar;
axis equal

figure(2)
prim2 = prim_vars(GRID2.x,GRID2.y);
contourf(GRID2.x,GRID2.y,prim2(:,:,4),100)
colorbar;
axis equal
% plot_2D_grid(GRID,'k')



function plot_2D_grid(GRID,linspec)
hold on;
plot(GRID.x,GRID.y,linspec);
plot(GRID.x.',GRID.y.',linspec);
end

function GRID = ms1_grid(h,Nfine)
% undeformed initial domain
xi_range  = [0.5,1.0];
eta_range = [0.0,0.5];

% expansion ratios
r_xi  = 0.9993; % 0.993 in paper - but that must be a typo
r_eta = 1.0;

xi0  = geomspace(  xi_range(1),  xi_range(2),  r_xi,  Nfine(1) );
eta0 = geomspace( eta_range(1), eta_range(2), r_eta,  Nfine(2) );

% coarsened grid
% s = 2^(h-1); % h = 1 corrseponds to finest grid
[XI,ETA]  =  ndgrid( xi0(1:h:Nfine(1)), eta0(1:h:Nfine(2)) );

GRID = struct();
GRID.imax = size(XI,1);
GRID.jmax = size(XI,2);

GRID.x = x_map(XI,ETA);
GRID.y = y_map(XI,ETA);
end

function val = a();     val = 0.05; end
function val = rho_0(); val = 1.0;  end
function val = p_0();   val = 1.0;  end
function val = u_w();   val = 1.0;  end


function x = x_map(xi,eta)
x = (4/3)*(xi.^2 -1/4) + 1 + 0*eta;
end

function y = y_map(xi,eta)
x = x_map(xi,eta);
y = eta + a()*sin(2*pi*x);
end

function y0 = y0fun(x,y)
y0 = y - a()*sin(2*pi*x);
end

function dydx = diff_map(x,y)
dydx = 2*pi*a()*cos(2*pi*x) + 0*y;
end

function rho = rho_ms(x,y)
y0 = y0fun(x,y);
rho = rho_0() + y0.^2;
end

function u = u_ms(x,y)
y0 = y0fun(x,y);
u = u_w() + y0;
end

function v = v_ms(x,y)
dydx = diff_map(x,y);
u = u_ms(x,y);
v = dydx.*u;
end

function p = p_ms(x,y)
y0 = y0fun(x,y);
p = p_0() + y0.^2;
end

function prim = prim_vars(x,y)
prim = zeros(size(x,1),size(x,2),4);
prim(:,:,1) = rho_ms(x,y);
prim(:,:,2) =  u_ms(x,y);
prim(:,:,3) =  v_ms(x,y);
prim(:,:,4) =  p_ms(x,y);
end